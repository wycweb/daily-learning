    1.单纯的interface可以统一方法的调用，但是不能统一对象的实例化
    2.面向对象主要做的事情：实例化对象 调用方法(完成业务逻辑)
    3.如果想要一块代码保持稳定，不要反反复复出现new的关键字。一段代码中没有new的出现会保障代码的稳定，才能逐步实现OCP
    4.上面的这句话只是表象，实质是一段代码如果保持稳定，就不应该负责对象的实例化
    5.对象的实例化过程是不可能被消除的
    6.想办法把对象实例化的过程转移到其他的代码块或代码片段中
    7.代码中总是会存在不稳定的情况，隔离这部分不稳定代码，保障其他的代码是稳定的
    IOC其实就是将不稳定封装隔离到一起，IOC就是将变动集中在一处，当代码发生变动时，只需要针对容器这块进行改动，无需到处需改代码.
    8.软件迭代过程中会有很多变化的过程，所以就造成了不稳定的存在
    变化分为两大类，一类是业务变动，另一类是技术选型的变动，如底层存储从MySQL变为SQLserver
    
    计算机的代码：现实生活中的规律、现实生活中的业务
    
##IOC、DI、DIP
    DIP: Dependency Inversion Principle 依赖倒置
    高层模块不应该依赖低层模块，两证都应该依赖抽象(抽象是高层次的，具体是低层次的)
    抽象不应该依赖细节
    细节应该依赖抽象
    
    DI: Dependency Injection 依赖注入(基本都是属性注入和构造注入)
    1.属性注入
    例如使用set方式，获取到属性的具体形式
    private Hero hero;
    
    public void setIc(IC ic){
        this.ic = ic
    }
    2.构造注入
    通过构造函数使属性有具体形式
    public class A{
        private Hero hero;
        
        public A(Hero hero){
        
        }    
    }
    3.函数注入

    实现/应用 DI
    
##注意    
    工厂方法 + 反射 并不是  IOC + DI，工厂方式 + 反射只能说是实现了大部分OCP的形式
    改动配置文件是否违反OCP原则：配置文件不应该理解为是系统的一部分，配置文件是应该系统外部的，而不属于代码本身
    
    
##为什么通过IOC使系统会变得稳定
   IOC是把类主动给调用处，实例化是通过实例化主动拿到类来使用
   通过容器的思维，能够解决各个模块之间的直接依赖，通过容器中间层对各个模块进行解耦    
    
## 变化

IOC抽象概念：归根结底是控制权属于谁。

抽象不合理点讲，控制权是程序员或用户。对于封装的不好的代码，所有的控制权都是在程序员身上。

假如基础接口封装的非常好，就无需对某些主体程序进行变更，这个时候代码的控制权就是在用户身上了。 